:doctype: book
:toc:
:toclevels: 3

= Hashing and Encryption

== Hash functions:

One of the basic primitive of cryptography.
It is a one way function used to create a succinct representation of a data.
No matter how large the data is, it creates a bound size representation of that data.
So, an unbounded input size, represented/mapped to a bounded output
Fast to compute, hard to reverse (from output to input).
Collusion resistant: Hard to compute 2 inputs that have the same hash.
So, at its core a hash function is used to uniquely identify data. 


== Hash function in action:

SHA256 is a hash function that belongs to the family of SHA-2 (Secure Hash Algorithm 2), which is a set of cryptographic hash functions designs.

This section basically shows an example of hash in practive from github:  https://guggero.github.io/blockchain-demo/#!/hash


== Properties of Hash Funtions:


- accept unbounded size input
- map to a bounded fixed size output
- speed, the function must be quick to compute

- an one-way function (Pre-image resistence):  Given a hash value, it should be computationally infeasible to find any input that produces that hash.
    Stops attackers from recovering the original input from the hash.
    Protects against reverse-engineering hashed passwords.

- Second Pre-Image Resistance: Given a specific input and its hash, it should be computationally infeasible to find a different input that produces the same hash.
    This is about modifying a known input without changing its hash. Used for Document tampering, signature forgery

- Collision resistence: An attacker is free to find any two completely different files (arbitrary inputs) that hash to the same value.
    This is especially dangerous for digital signatures, The attacker gets you to sign a benign file.
	the famous SHA-1 collision attack (Google’s SHAttered project in 2017)


Key Difference: Freedom of Choice
- Pre-image resistance: The attacker is stuck with a specific hash.
- Second pre-image resistance: The attacker is stuck with a specific input.
- Collision resistance: The attacker is free to choose everything.

Weak collision resistance, which is also called second preimage resistance.
Strong collision resistance, is also known as Collision resistence.



Summary:

[cols="1,3,3", options="header"]
|===
| Hash Property | Attack Example | Real-World Risk

| Pre-Image Resistance
| Recover original input from a known hash (e.g., cracking a hashed password)
| Hash reversal (password recovery, leaking sensitive data)

| Second Pre-Image Resistance 
| Given a signed document, find a *different* document with the same hash
| Document tampering (targeted forgery of signed documents)

| Collision Resistance
| Create two distinct documents that hash to the same value before signing
| Signature forgery (swap benign document with malicious one after signing)
|===



== Hash functions - Cryptographic vs Non-cryptographic

There are 2 types:
- Cryptographic hash functions
  provide security guarantess and are supposed to be collision resistent
  slower than non-cryptographic ones, but used when security is a primary concern
 

- Non-cryptographic hash functions
  much faster, but weeker guarantees,
  used in file retrival and indexing, can also be used when users/nodes are known to NOT be malicious. 

Note: important to rememnber that no hash function is fully collision resistant, there's always a possibility of a collusion given the fact that
the input domain is larger than the output range.
This is a fundamental concept known as the Pigeonhole Principle, which guarantees that collisions must exist for any hash function with a fixed output size.

Why Collisions Are Inevitable

The math behind it:
- A hash function maps inputs of unbounded or very large size (potentially infinite) into outputs of fixed, finite size (say 256 bits).
- Because the output space is finite (for example, 2^{256} possible hashes), but the input space is effectively infinite or at least much larger, there must be multiple distinct inputs that produce the same output.

This is simply like having 10 pigeonholes but 11 pigeons — one hole has to hold at least two pigeons.


So, Collision resistance doesn’t mean no collisions exist — that’s impossible.
- Instead, it means it is computationally infeasible to find such collisions.
- In other words, finding a collision should require an impractical amount of time and resources (far beyond current computing capabilities).

If collisions become easy to find (like SHA-1 today), the hash function is considered broken for cryptographic use and should be replaced by stronger functions (SHA-256, SHA-3, etc.).


== Hash function - Applications


Hash functions also provide data integrity, if a single bit change , the hash changes dramatically.

We can also use hash functions as commitment schemes. a commitment schemes not only binds an input data to an output data, but also gives you strong privacy garantees.
Ensuring not only integrity but also privacy. From the output we can obtain any information about the input.
Note, we will talk and explain commitment schemes below. 


*Take-away*: hash function is one of the most basic fundamental cryptographic primitives.
		   they are essential for securing data. verifying identities, ensuring the integrity of transactions in blockchains systems.


== Commitment schemes

A commitment scheme is a cryptographic primitive that allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later.

What is a Commitment Scheme?

A commitment scheme is like a digital sealed envelope. It lets you:
1.	Commit: Lock in a value secretly (put it in the envelope).
2.	Reveal: Later, open the envelope to reveal the committed value.
3.	Guarantee:
 3.1. Hiding: Nobody can figure out the committed value before you reveal it.
 3.2. Binding: You cannot change the value after committing.

How Hash Functions Implement Commitment

You can use a hash function H to build a commitment scheme:

1. Commit phase:
- You pick a value x you want to commit to.
- You pick a random nonce (random value) r to keep things secure.
- Compute the commitment: C = H(x | r) , where | denotes concatenation.
- You publish or send C as your commitment.

2. Reveal phase:
- When ready, reveal x and r.
- Anyone can verify the commitment by checking:  H(x \| r) \stackrel{?}{=} C

If the equality holds, the commitment is valid.

Why It Works: Properties Needed
- Hiding: because r is random and secret, C hides x. Without r, no one can guess x from C (assuming hash behaves like a random oracle).
- Binding: Due to collision resistance, you cannot find x’, r’ \neq x, r such that H(x’ \| r’) = H(x \| r) = C.
           So you can’t change your committed value after the fact.

Real-World Use Cases
- Secure Auctions: Commit your bid secretly, then reveal it later without cheating.
- Zero-Knowledge Proofs: Commit to secret values to prove statements without revealing the secrets.
- Blockchain: Commit transactions or states in a tamper-proof way.
- Digital Contracts: Commit to contract terms before revealing them publicly.

Notes
- Using the random nonce r is critical to ensure hiding.
- Without r, it may be possible to guess or brute force x if the domain is small.


== Guessing game and quiz

In this session one example of a guessing game is given to show how we use hashing function for commitment schemes.
two users bet some money to try to guess each others choices between two flags.
Who guesses the color of the flag the other has chosen wins the money.

The solution using hash in this case would be each one records a video of his choice and publishes the hash of the video
on internet where both of them have access. after both of them publishing this proof. they can revel their choice, and verify if
the other is not lying by using the previously published hash.


   
== Encryption - Symmetric vs Assymetric

Hashing and Encryption


- Symmetric Encryption: also known as secret-key encryption, is a type of cryptographic system where the same key is used for both encryption and decryption of data.
Both the sender and the recipient must have the shared secret key in advance, which is challenging when the parties dont know each other, or dont meet each other first.

Examples: ChaCha20, AES, DES, Blowfish, Twofish, Serpent

Provides: Confidentiality
Does not provide: Integrity, Authenticity, Non-Repudiation


- Assymetric encryption: also known as public-key encryption, uses two related keys: a public key and a private key.
The public key is used to encrypt messages, and only the corresponding private key can decrypt them.
The key difference is that the public key can be shared openly without compromising security, while the private key remains secret.
It is computational more expansive than the symmetric one, making it less suitable for large amounts of information.
One interesting application of assymetric encryption is key exchange, by using assymetric encryption for securely exchanging keys, the two parties can than switch to
symmtric encryption for on going communication. it allows faster and more efficient data transmission while maintaning a high level of security.

Examples: RSA, ElGamal, Paillier

Asymmetric Encryption Guarantees

Provides(similar to symmetric): Confidentiality
Does not provide: Integrity, Authenticity, Non-Repudiation



== Assymetric encryption explained example.

Two breakthrough algorithms that allow secure communication between two parties without a shared secret:

- RSA algorithm (1977): Relies on number theory, specially in prime numbers and the difficulty of prime number factorization.
  It provides a public/private key pair which are really long numbers.
  Then if two parties want to communicate securely the first sends it public key to the other. Upon receipt the public key it uses the public key
  to encrypt the message, which that  only the owner of the public key can read the message.  And this is what we call assymetric cryptography and this is computationally expansive.


- Diffie-Hellman key exchange algorithm (1976/77):
it is a mathematical method of securely generating a symmetric cryptographic key over a public channel and was one of the first protocols as conceived by Ralph Merkle and named after Whitfield Diffie and Martin Hellman.

Let's see an example:

A and B want to exchange messages, so

Parameters:
These values are known to everyone (including attackers):
- p: A large prime number (modulus)
- g: A primitive root modulo p (called the base or generator)

Example: p = 23, g = 5

* Alice generates:
** A secret random number a
** Computes A = g^a \mod p
** Sends A to Bob
*** Message from Alice to Bob: A = g^a mod p
* Bob generates:
** A secret random number b
** Computes B = g^b \mod p
** Sends B to Alice
*** Message from Bob to Alice: B = g^b mod p

* Both compute the shared secret:
** Alice receives B, computes: S = B^a \mod p = g^{ba} \mod p
** Bob receives A, computes: S = A^b \mod p = g^{ab} \mod p

Now both share the same secret S, without having sent it directly.

Notes: The shared key is never sent — only derived.
- DH by itself provides key agreement, not encryption or authentication.
- It’s vulnerable to man-in-the-middle attacks unless combined with authentication (like in TLS).


More references on Assymetric encryption:

https://en.wikipedia.org/wiki/Public-key_cryptography

https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange

https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange

https://cryptotools.net/rsagen

https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/4-Encryption-slides.html#/9



Take-away:

Encryption schemes are designed to provide confidentiality of sensitive data and symmetric and assymetric encryption are the 2 main types of it.
Symmetric encryption is fast, however require previous exchange of keys.
Assymetric encryption solves the key exchange problem, and it is good for transmiting sensitive information, however it is much slower.
