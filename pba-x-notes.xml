<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>PBA-x Compendium</title>
<subtitle>Wave 3 modules notes</subtitle>
<date>2025-08-20</date>
</info>
<preface>
<title></title>
<simpara>This document contains comprehensive notes from the third wave of PBA-x, the online version of the Polkadot Blockchain Academy (PBA) program.
The primary objective is to transform raw notes from video lessons into well-structured, readable content that serves as a definitive reference guide for learners to refer to and review course material.</simpara>
</preface>
<chapter xml:id="_module_introduction_to_cryptography">
<title>Module: Introduction to Cryptography</title>
<section xml:id="_cryptography_principles">
<title>Cryptography Principles</title>
<section xml:id="_cryptography_overview">
<title>Cryptography overview</title>
<simpara>Cryptography brief historic and current use of cryptography.
In the past, the design of cryptography protocols used to be more based on heuristics (relying on intuition)
and the methods we designed mostly in an ad hoc fashion. Nowadays a more scientific approach
is used, we design methods with well defined models that come with mathematical proofs of security.
The main idea is that the methods are guaranteed to be secure in the specified model unless some underlaying assumption is false.</simpara>
<simpara>Cryptography provides a collection of tools for secure interaction in the presence of adversaries.</simpara>
<itemizedlist>
<listitem>
<simpara>public key encryption</simpara>
</listitem>
<listitem>
<simpara>digital signatures</simpara>
</listitem>
<listitem>
<simpara>zero knowledge proofs</simpara>
</listitem>
<listitem>
<simpara>anonymous digital cache</simpara>
</listitem>
<listitem>
<simpara>multi-party computation</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_secure_communication">
<title>Secure communication</title>
<simpara>A user <literal>A</literal> wants to send a secure message <literal>m</literal> to user <literal>B</literal>.</simpara>
<simpara>In cryptography we need to specify what secure means in this case, in other words we need to
describe which security graranties are desired. We need that because we do not want to start
designing clever algorithms without knowing the exact goals we want to achieve.</simpara>
<simpara>In this case security communication could means many things, for instance:</simpara>
<itemizedlist>
<listitem>
<simpara>Confidentiality:  the message <literal>m</literal> must remain secret (only the recipient must read).</simpara>
</listitem>
<listitem>
<simpara>Authenticity: the recipient <literal>B</literal> is sure about the origin of message <literal>m</literal> is the sender <literal>A</literal>, and not anybody else.</simpara>
</listitem>
<listitem>
<simpara>Non-repudiation: <literal>A</literal> cannot deny the fact that it sent the message <literal>m</literal> if he/she did it.</simpara>
</listitem>
<listitem>
<simpara>(data) Integrity: if message <literal>m</literal> is tampered (modified/manipulated) with, if will be easily noticed.</simpara>
</listitem>
<listitem>
<simpara>(data) Availability: not always considered as a cryptographic guarantee, but we want the data to be available to access.</simpara>
</listitem>
<listitem>
<simpara>(data) Verifiability: in some contexts, we want to prove that possibly sensitive data satisfy some conditions/properties without revealing the information (zero knowledge proofs).</simpara>
</listitem>
</itemizedlist>
<simpara>After defining these goals we have to think about how to achieve these goals.
This envolves typically specifying two points:</simpara>
<itemizedlist>
<listitem>
<simpara>Define the base layer we will start with:</simpara>
</listitem>
<listitem>
<simpara>Specify the schemes or methods that make use of this base layer to achieve the goals.</simpara>
</listitem>
</itemizedlist>
<simpara>In the case of the previous example of secure communication,
we can for instance, first start by defining an insecure communication channel over the internet to allow <literal>A</literal> sending messages to <literal>B</literal>.
Then, we speficy the methods that may include encryption schemes, digital signatures and other tools that will
turn this insecure communication into a secure channel that achieve the goals that we described in the begining.</simpara>
<section xml:id="_secure_communication_an_example">
<title>Secure communication: an example</title>
<simpara>How A sends a secure message to B if the communication channel (cc) is insecure.</simpara>
<informalexample>
<simpara><literal>A</literal>  ------cc----&#8594;  <literal>B</literal></simpara>
</informalexample>
<simpara>First scenario, <literal>A</literal> knows <literal>B</literal> and both meet personally to exchange copies of a key for a specific lock,
then <literal>A</literal> uses this lock to lock the message inside and send the box to <literal>B</literal>.
<literal>A</literal> knows that only <literal>B</literal> can have a key to open that lock. So the message is secured.</simpara>
<simpara>Now, lets assume that <literal>A</literal> and <literal>B</literal> can not meet each other, or they do not know each other.
How can they exchange the message securely now ?
<literal>A</literal> can actually get a box and send an unbraekable lock to <literal>B</literal>, <literal>B</literal> in his turn gets the lock of <literal>A</literal>
and puts his own unbreakable lock inside a box and send back to <literal>A</literal>.
<literal>A</literal> receives the lock of <literal>B</literal> which it can remove from the box, and use the lock of <literal>B</literal> to lock the secure message
inside a box and send back to <literal>B</literal>, now locked with the lock of <literal>B</literal>, so only <literal>B</literal> can open and read it.</simpara>
<simpara>This example shows a basic and simplified example of exchanging cryptographic encryption keys.</simpara>
</section>
</section>
<section xml:id="_kefckhoffs_principle">
<title>Kefckhoff&#8217;s Principle:</title>
<simpara>Created by Auguste Kerckhoffs in the 19th century.</simpara>
<simpara>The Kerckhoffs' principle states that the security of a cryptographic system should not depend
on the secrecy of the algorithm, but rather on the secrecy of the cryptographic key.
The system should remain secure even if the algorith is publicly known, with the key being the only
confidential element.</simpara>
<simpara>In other words:</simpara>
<screen>A cryptosystem should be secure even if everything about the system is public knowledge, EXCEPT THE KEY.</screen>
<simpara>We should not rely in the secrecy of the method, which is known as security by obscurity.
We should not hope that no one is able or capable of figuring it out.</simpara>
<simpara>Reasons for that:</simpara>
<itemizedlist>
<listitem>
<simpara>It is easier to store a short key than the description of the method.</simpara>
</listitem>
<listitem>
<simpara>if we loose a key it is easier to replace for a new one, than creating a new method.</simpara>
</listitem>
<listitem>
<simpara>having the method public, allows for the community to work together to validate the method as a secure method.</simpara>
</listitem>
</itemizedlist>
<simpara>Following Kerckhoffs principle allows for rigorous testing and analysis, ensuring the security of the method or system that uses it.</simpara>
<simpara>Therefore, the power of cryptography methods relies on good choice of keys.
Keys that are random and unpredictable are harder to crack.
We measure the level of randomness of a key via entropy (the amount of non-redundant information cointained, less random lower entropy).
Choosing keys from high entropy distributions, adversaries will have lower probability of obtaining them.</simpara>
</section>
<section xml:id="_take_away">
<title>Take-away</title>
<itemizedlist>
<listitem>
<simpara>Criptography is today a core science for building secure and highly complex decentralized systems.</simpara>
</listitem>
<listitem>
<simpara>We want to build systems with strong secutiry guarantess, with the smallest amount of assumptions as possible,
and at the same time ensuring high performances. And this is an important trade-off.</simpara>
</listitem>
<listitem>
<simpara>Understanding the basic primitives of cryptographic tools are core to achieve that.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_hashing_and_encryption">
<title>Hashing and Encryption</title>
<section xml:id="_hash_functions">
<title>Hash functions</title>
<simpara>Hash functions are one of the fundamental building blocks of cryptography.
A hash function is a one-way function that creates a compact representation of input data.
No matter how large the input, the output—called the hash—is of fixed size.
In other words, hash functions map an unbounded input space to a bounded output space.
They are designed to be fast to compute in the forward direction.
However, reversing the process—recovering the input from the hash—is computationally infeasible.
Good hash functions are also collision-resistant.
That means it is very hard to find two different inputs that produce the same hash.
At their core, hash functions are used to uniquely identify data.</simpara>
<section xml:id="_hash_function_in_action">
<title>Hash Function in Action</title>
<simpara>SHA-256 is a widely used hash function that belongs to the SHA-2 (Secure Hash Algorithm 2) family.
SHA-2 is a collection of cryptographic hash functions designed for secure data hashing.</simpara>
<simpara>To see SHA-256 in action, we will use a visual demo available online.
The demo is hosted at <link xl:href="https://guggero.github.io/blockchain-demo/#!/hash">https://guggero.github.io/blockchain-demo/#!/hash</link>.</simpara>
<simpara>It is an interactive tool that helps you understand how hash functions behave with different inputs.
This version is a complete rewrite of Anders Brownworth&#8217;s original Blockchain Demo.
While the underlying code has changed, the core educational idea from Brownworth&#8217;s excellent demo video remains.</simpara>
<simpara>Try changing the input data in the demo and observe how the hash output changes.
Even small changes in the input produce completely different hashes.
This property is known as the avalanche effect.
It demonstrates how hash functions are sensitive to input and useful for ensuring data integrity.</simpara>
</section>
<section xml:id="_properties_of_hash_funtions">
<title>Properties of Hash Funtions:</title>
<itemizedlist>
<listitem>
<simpara>accept unbounded size input</simpara>
</listitem>
<listitem>
<simpara>map to a bounded fixed size output</simpara>
</listitem>
<listitem>
<simpara>speed, the function must be quick to compute</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">an one-way function (pre-image resistence)</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>given a hash value, it should be computationally infeasible to find any input that produces that hash.</simpara>
</listitem>
<listitem>
<simpara>stops attackers from recovering the original input from the hash.</simpara>
</listitem>
<listitem>
<simpara>protects against reverse-engineering hashed passwords.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">second Pre-Image Resistance</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>given a specific input and its hash, it should be computationally infeasible to find a different input that produces the same hash.</simpara>
</listitem>
<listitem>
<simpara>this is about modifying a known input without changing its hash.</simpara>
</listitem>
<listitem>
<simpara>used for Document tampering, signature forgery</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">collision resistence</emphasis>: An attacker is free to find any two completely different files (arbitrary inputs) that hash to the same value.</simpara>
<itemizedlist>
<listitem>
<simpara>this is especially dangerous for digital signatures, The attacker gets you to sign a benign file.</simpara>
</listitem>
<listitem>
<simpara>the famous SHA-1 collision attack (Google’s SHAttered project in 2017)</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Key differences</emphasis>: Freedom of Choice
- Pre-image resistance: The attacker is stuck with a specific hash.
- Second pre-image resistance: The attacker is stuck with a specific input.
- Collision resistance: The attacker is free to choose everything.</simpara>
<simpara>Weak collision resistance, which is also called second preimage resistance.
Strong collision resistance, is also known as Collision resistence.</simpara>
</section>
<section xml:id="_summary">
<title>Summary</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="14.2857*"/>
<colspec colname="col_2" colwidth="42.8571*"/>
<colspec colname="col_3" colwidth="42.8572*"/>
<thead>
<row>
<entry align="left" valign="top">Hash Property</entry>
<entry align="left" valign="top">Attack Example</entry>
<entry align="left" valign="top">Real-World Risk</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Pre-Image Resistance</simpara></entry>
<entry align="left" valign="top"><simpara>Recover original input from a known hash (e.g., cracking a hashed password)</simpara></entry>
<entry align="left" valign="top"><simpara>Hash reversal (password recovery, leaking sensitive data)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Second Pre-Image Resistance</simpara></entry>
<entry align="left" valign="top"><simpara>Given a signed document, find a <emphasis role="strong">different</emphasis> document with the same hash</simpara></entry>
<entry align="left" valign="top"><simpara>Document tampering (targeted forgery of signed documents)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Collision Resistance</simpara></entry>
<entry align="left" valign="top"><simpara>Create two distinct documents that hash to the same value before signing</simpara></entry>
<entry align="left" valign="top"><simpara>Signature forgery (swap benign document with malicious one after signing)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_hash_functions_cryptographic_vs_non_cryptographic">
<title>Hash Functions: Cryptographic vs Non-cryptographic</title>
<simpara>There are 2 types:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Cryptographic hash functions</emphasis>:
provide security guarantess and are supposed to be collision resistent
slower than non-cryptographic ones, but used when security is a primary concern</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Non-cryptographic hash functions</emphasis>:
much faster, but weeker guarantees,
used in file retrival and indexing, can also be used when users/nodes are known to NOT be malicious.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>It is important to rememnber that no hash function is fully collision resistant, there&#8217;s always a possibility of a collusion given the fact that
the input domain is larger than the output range.
This is a fundamental concept known as the <emphasis role="strong">Pigeonhole Principle</emphasis>, which guarantees that collisions must exist for any hash function with a fixed output size.</simpara>
</note>
<simpara><emphasis role="strong">Why Collisions Are Inevitable</emphasis>?</simpara>
<simpara>The rationale behind that:</simpara>
<screen>The reason collisions must happen is based on basic math and logic.
A hash function takes inputs that can be infinitely large or very big.
But it produces outputs of fixed size, for example, 256 bits.
This means there are only a finite number of possible outputs—specifically, 2^256.
Since the input space is much larger than the output space, some inputs must share the same output.
This situation is known as a collision.
You can think of it like having 10 pigeonholes but 11 pigeons.
With more pigeons than holes, at least one hole must contain two pigeons.
Similarly, multiple inputs must map to the same hash output.</screen>
<simpara>So, Collision resistance does not mean no collisions exist.</simpara>
<itemizedlist>
<listitem>
<simpara>Instead, it means it is computationally infeasible to find such collisions.</simpara>
</listitem>
<listitem>
<simpara>In other words, finding a collision should require an impractical amount of time and resources (far beyond current computing capabilities).</simpara>
</listitem>
</itemizedlist>
<simpara>If collisions become easy to find (like SHA-1 today), the hash function is considered broken for cryptographic use and should be replaced by stronger functions (SHA-256, SHA-3, etc.).</simpara>
</section>
<section xml:id="_hash_function_applications">
<title>Hash Function: Applications</title>
<simpara>Hash functions also provide data integrity.
Even a single bit change in the input causes a completely different hash output.
This makes it easy to detect any tampering with the data.</simpara>
<simpara>Hash functions can also be used as commitment schemes.
A commitment scheme binds input data to a specific output, providing strong privacy guarantees.
This means the output hides all information about the input.
With a commitment scheme, you can prove you committed to some data without revealing it.</simpara>
<simpara>We will see commitment schemes in more detail later.</simpara>
<section xml:id="_take_away_2">
<title>Take-away</title>
<itemizedlist>
<listitem>
<simpara>A hash function is one of the most fundamental building blocks in cryptography.</simpara>
</listitem>
<listitem>
<simpara>Hash functions produce fixed-size outputs from inputs of any size.</simpara>
</listitem>
<listitem>
<simpara>They are designed to be fast to compute and hard to reverse.</simpara>
</listitem>
<listitem>
<simpara>Hash functions ensure data integrity by producing drastically different outputs for small input changes.</simpara>
</listitem>
<listitem>
<simpara>They are essential for securing data and verifying identities.</simpara>
</listitem>
<listitem>
<simpara>Hash functions play a critical role in blockchain technology to ensure transaction integrity and security.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_commitment_schemes">
<title>Commitment schemes</title>
<simpara>A commitment scheme is a cryptographic primitive that allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later.</simpara>
<simpara>In other words, a commitment scheme is a way to "lock" a secret value.
It lets you commit to a value without revealing it right away.
Later, you can "open" the commitment to prove what the original value was.</simpara>
<simpara>So, it lets you:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Commit</emphasis>: Lock in a value secretly (put it in the envelope).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Reveal</emphasis>: Later, open the envelope to reveal the committed value.</simpara>
</listitem>
</itemizedlist>
<simpara>And ensures two important properties:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Hiding:</emphasis> No one can guess the committed value before you reveal it.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Binding:</emphasis> You cannot change the value after committing.</simpara>
</listitem>
</itemizedlist>
<simpara>Commitment schemes are like putting a message in a locked box.
You show the box to others but keep the message secret.
When ready, you open the box and reveal the message.
This helps in secure protocols where privacy and honesty matter.
Hash functions are often used to build commitment schemes.</simpara>
<section xml:id="_how_hash_functions_implement_commitment">
<title>How Hash Functions Implement Commitment</title>
<simpara>You can use a hash function to build a simple commitment scheme.</simpara>
<section xml:id="_commit_phase">
<title>Commit Phase</title>
<itemizedlist>
<listitem>
<simpara>Choose a value <literal>x</literal> that you want to commit to.</simpara>
</listitem>
<listitem>
<simpara>Pick a random value <literal>r</literal> (called a nonce) to keep it secure.</simpara>
</listitem>
<listitem>
<simpara>Compute the commitment: <literal>C = H(x | r)</literal> where <literal>|</literal> means concatenation.</simpara>
</listitem>
<listitem>
<simpara>Share <literal>C</literal> as your commitment. Keep <literal>x</literal> and <literal>r</literal> secret for now.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_reveal_phase">
<title>Reveal Phase</title>
<itemizedlist>
<listitem>
<simpara>When you&#8217;re ready, reveal both <literal>x</literal> and <literal>r</literal>.</simpara>
</listitem>
<listitem>
<simpara>Anyone can verify your commitment by checking:
<literal>H(x | r) == C</literal></simpara>
</listitem>
<listitem>
<simpara>If the values match, the commitment is valid.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_why_it_works_required_properties">
<title>Why It Works: Required Properties</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Hiding:</emphasis>
The random <literal>r</literal> hides <literal>x</literal>.
Without <literal>r</literal>, no one can guess <literal>x</literal> from <literal>C</literal>.
This assumes the hash behaves like a random oracle.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Binding:</emphasis>
Because of collision resistance, you can&#8217;t find other values <literal>x'</literal>, <literal>r'</literal>
such that <literal>H(x' | r') == H(x | r) == C</literal> unless they are the same as <literal>x</literal> and <literal>r</literal>.
This means you can&#8217;t change your committed value later.</simpara>
</listitem>
</itemizedlist>
<simpara>Commitment schemes built from hash functions are simple but powerful.
They are used in many cryptographic protocols to ensure fairness and privacy.</simpara>
</section>
<section xml:id="_real_world_use_cases">
<title>Real-World Use Cases</title>
<simpara>Commitment schemes are used in many real-world cryptographic systems.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Secure Auctions:</emphasis>
Bidders commit to their bids in secret.
Later, they reveal the bids.
This prevents cheating or changing bids after seeing others.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Zero-Knowledge Proofs:</emphasis>
Commitments hide secret values.
You can prove something is true without showing the secret itself.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Blockchain:</emphasis>
Commitments are used to record transactions or states.
Once committed, the data cannot be changed without detection.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Digital Contracts:</emphasis>
Parties can commit to contract terms before revealing them.
This adds fairness and prevents manipulation.</simpara>
</listitem>
</itemizedlist>
<simpara>These use cases show how commitments provide both privacy and trust.</simpara>
</section>
</section>
</section>
<section xml:id="_real_world_use_cases_2">
<title>Real-World Use Cases</title>
<simpara>Commitment schemes are used in many real-world cryptographic systems.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Secure Auctions:</emphasis>
Bidders commit to their bids in secret.
Later, they reveal the bids.
This prevents cheating or changing bids after seeing others.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Zero-Knowledge Proofs:</emphasis>
Commitments hide secret values.
You can prove something is true without showing the secret itself.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Blockchain:</emphasis>
Commitments are used to record transactions or states.
Once committed, the data cannot be changed without detection.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Digital Contracts:</emphasis>
Parties can commit to contract terms before revealing them.
This adds fairness and prevents manipulation.</simpara>
</listitem>
</itemizedlist>
<simpara>These use cases show how commitments provide both privacy and trust.</simpara>
</section>
<section xml:id="_encryption_symmetric_vs_asymmetric">
<title>Encryption: Symmetric vs Asymmetric</title>
<simpara>Encryption is the process of transforming readable data (plaintext) into an unreadable form (ciphertext) using a cryptographic key.
Only someone with the correct key can convert the ciphertext back into the original plaintext.</simpara>
<simpara>There are two main types of encryption: symmetric and asymmetric.</simpara>
<section xml:id="_symmetric_encryption">
<title>Symmetric Encryption</title>
<itemizedlist>
<listitem>
<simpara>Also called secret-key encryption.</simpara>
</listitem>
<listitem>
<simpara>The same key is used for both encryption and decryption.</simpara>
</listitem>
<listitem>
<simpara>Both the sender and receiver must share this key in advance.</simpara>
</listitem>
<listitem>
<simpara>This can be difficult if the parties have never met or don&#8217;t already trust each other.</simpara>
</listitem>
</itemizedlist>
<simpara>Examples: ChaCha20, AES, DES, Blowfish, Twofish, Serpent</simpara>
<section xml:id="_guarantees">
<title>Guarantees</title>
<simpara><emphasis role="strong">Provides:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Confidentiality (keeps data secret)</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Does NOT provide:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Integrity (detecting tampering)</simpara>
</listitem>
<listitem>
<simpara>Authenticity (proving who sent the message)</simpara>
</listitem>
<listitem>
<simpara>Non-repudiation (preventing denial of sending)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_asymmetric_encryption">
<title>Asymmetric Encryption</title>
<itemizedlist>
<listitem>
<simpara>Also called public-key encryption.</simpara>
</listitem>
<listitem>
<simpara>Uses a key pair: one public, one private.</simpara>
</listitem>
<listitem>
<simpara>The public key encrypts the data.</simpara>
</listitem>
<listitem>
<simpara>Only the matching private key can decrypt it.</simpara>
</listitem>
<listitem>
<simpara>The public key can be shared openly.</simpara>
</listitem>
<listitem>
<simpara>The private key must be kept secret.</simpara>
</listitem>
<listitem>
<simpara>Asymmetric encryption is more computationally expensive than symmetric.</simpara>
</listitem>
<listitem>
<simpara>It is not ideal for encrypting large amounts of data.</simpara>
</listitem>
</itemizedlist>
<simpara>A common use is secure key exchange.
Two parties can exchange a symmetric key using asymmetric encryption.
Then they switch to symmetric encryption for ongoing communication.
This gives the speed of symmetric encryption with the security of asymmetric key setup.</simpara>
<simpara>Examples: RSA, ElGamal, Paillier</simpara>
<section xml:id="_guarantees_2">
<title>Guarantees</title>
<simpara><emphasis role="strong">Provides:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Confidentiality (same as symmetric)</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Does NOT provide:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Integrity</simpara>
</listitem>
<listitem>
<simpara>Authenticity</simpara>
</listitem>
<listitem>
<simpara>Non-repudiation</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="_assymetric_encryption_explained_example">
<title>Assymetric Encryption: Explained Example</title>
<simpara>Two breakthrough algorithms that allow secure communication between two parties without a shared secret:</simpara>
<itemizedlist>
<listitem>
<simpara>RSA algorithm (1977): Relies on number theory, specially in prime numbers and the difficulty of prime number factorization.
It provides a public/private key pair which are really long numbers.
Then if two parties want to communicate securely the first sends it public key to the other. Upon receipt the public key it uses the public key
to encrypt the message, which that  only the owner of the public key can read the message.  And this is what we call assymetric cryptography and this is computationally expansive.</simpara>
</listitem>
<listitem>
<simpara>Diffie-Hellman key exchange algorithm (1976/77):
it is a mathematical method of securely generating a symmetric cryptographic key over a public channel and was one of the first protocols as conceived by Ralph Merkle and named after Whitfield Diffie and Martin Hellman.</simpara>
</listitem>
</itemizedlist>
<simpara>Let&#8217;s see an example:</simpara>
<informalexample>
<simpara>A and B want to exchange messages</simpara>
</informalexample>
<simpara><emphasis role="strong">Parameters</emphasis>:
These values are known to everyone (including attackers):</simpara>
<itemizedlist>
<listitem>
<simpara>p: A large prime number (modulus)</simpara>
</listitem>
<listitem>
<simpara>g: A primitive root modulo p (called the base or generator)</simpara>
</listitem>
</itemizedlist>
<simpara>For instance, p = 23, g = 5</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Alice generates</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>A secret random number a</simpara>
</listitem>
<listitem>
<simpara>Computes A = g^a \mod p</simpara>
</listitem>
<listitem>
<simpara>Sends A to Bob</simpara>
<itemizedlist>
<listitem>
<simpara>Message from Alice to Bob: A = g^a mod p</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Bob generates</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>A secret random number b</simpara>
</listitem>
<listitem>
<simpara>Computes B = g^b \mod p</simpara>
</listitem>
<listitem>
<simpara>Sends B to Alice</simpara>
<itemizedlist>
<listitem>
<simpara>Message from Bob to Alice: B = g^b mod p</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Both compute the shared secret</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>Alice receives B, computes: S = B^a \mod p = g^{ba} \mod p</simpara>
</listitem>
<listitem>
<simpara>Bob receives A, computes: S = A^b \mod p = g^{ab} \mod p</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Now both share the same secret S, without having sent it directly.</simpara>
<simpara>Note:</simpara>
<itemizedlist>
<listitem>
<simpara>The shared key is never sent, only derived.</simpara>
</listitem>
<listitem>
<simpara>DH by itself provides key agreement, not encryption or authentication.</simpara>
</listitem>
<listitem>
<simpara>It’s vulnerable to man-in-the-middle attacks unless combined with authentication (like in TLS).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_take_away_3">
<title>Take-away</title>
<itemizedlist>
<listitem>
<simpara>Encryption protects the confidentiality of sensitive data.</simpara>
</listitem>
<listitem>
<simpara>There are two main types: symmetric and asymmetric encryption.</simpara>
</listitem>
<listitem>
<simpara>Symmetric encryption is fast and efficient.</simpara>
</listitem>
<listitem>
<simpara>But it requires both parties to share a secret key in advance.</simpara>
</listitem>
<listitem>
<simpara>Asymmetric encryption solves the key exchange problem.</simpara>
</listitem>
<listitem>
<simpara>It uses a public key to encrypt and a private key to decrypt.</simpara>
</listitem>
<listitem>
<simpara>However, asymmetric encryption is much slower.</simpara>
</listitem>
<listitem>
<simpara>In practice, both methods are often combined for secure and efficient communication.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_references">
<title>References</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://en.wikipedia.org/wiki/Public-key_cryptography">https://en.wikipedia.org/wiki/Public-key_cryptography</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cryptotools.net/rsagen">https://cryptotools.net/rsagen</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/4-Encryption-slides.html#/9">https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/4-Encryption-slides.html#/9</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_accounts_and_keys">
<title>Accounts and Keys</title>
<section xml:id="_wallets_and_accounts">
<title>Wallets and Accounts</title>
<simpara>A wallet stores the cryptographic keys needed to access and manage digital assets on the blockchain.
It doesn&#8217;t actually hold the cryptocurrency itself, but instead facilitates the secure storage and management of the keys required to carry out transactions.
They are known to be complicated even for technical people.</simpara>
</section>
<section xml:id="_accounts_and_self_custody">
<title>Accounts and Self Custody</title>
<simpara>Creating a blockchain account is a simple process, we just need to have a crypto wallet.</simpara>
<simpara>Usually while creating an account we are given a 12 words pass phrase known as seed phrase or recovery phrase.
The 12-word phrase is a way to securely store your private key in a format that’s easy to write down and remember.
It can recreate your wallet on any compatible wallet app or device.</simpara>
<simpara>This seed phrase is an implementation of the <literal>BIP-39</literal> standard, which converts a randomly generated number
(the private key seed) into a list of 12, 18, or 24 simple words from a predefined list.</simpara>
<simpara>This makes it easier to back up and reduces human error compared to copying a long hexadecimal string.
It can be used across different wallets that follow the same standard, meaning you’re not locked into one wallet provider.</simpara>
<simpara>If someone has your seed phrase, they own your wallet. It’s more important than your password or device.
If you lose your seed phrase, you lose access to your funds forever. There is no <literal>reset</literal> option in decentralized systems.</simpara>
<simpara><emphasis role="strong">Types of wallets</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Hot Wallet</emphasis>: A hot wallet is connected to the internet, allowing for easy and quick access to your digital assets.
They are typically used for daily transactions and trading due to their convenience.
Example: MetaMask</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Cold Wallet</emphasis>: A cold wallet is not connected to the internet, offering better security for the long-term storage of digital assets.
These are ideal for securely storing assets that aren&#8217;t needed for daily transactions.
Example: Ledger</simpara>
</listitem>
</itemizedlist>
<section xml:id="_cryptographic_keys_encoding">
<title>Cryptographic keys - Encoding</title>
<simpara>Computers work using binary data (long strings of 0s and 1s).
But these raw binary strings are very hard for humans to read, write, or share without making mistakes.
To solve this we use encoding, a way to represent binary data in a format that is more readable and manageable for humans.</simpara>
<simpara>Common Encoding Types in Cryptography &amp; Blockchains</simpara>
<itemizedlist>
<listitem>
<simpara>Hexadecimal (Base16)</simpara>
<itemizedlist>
<listitem>
<simpara>Widely used to represent hashes and keys in blockchains and cryptography.</simpara>
</listitem>
<listitem>
<simpara>Uses 16 characters (0-9 and A-F) to represent binary data in a compact, readable way.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<example>
<title>A SHA-256 hash looks like</title>
<simpara>3a3f8b8d65e6a6b7f3e9c2f4a7e5b6d4e3a3f9gha6e7c3d4a5f3b2e1d0a8c9b7f6</simpara>
</example>
<itemizedlist>
<listitem>
<simpara>Base64 (General Purpose, Not Often Used in Bitcoin)</simpara>
<itemizedlist>
<listitem>
<simpara>Very compact but can include confusing characters like +, /, and =.</simpara>
</listitem>
<listitem>
<simpara>Extremely useful in other contexts where compact binary-to-text encoding is needed.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Examples:  sending images or attachments in emails (MIME format), embedding small images in HTML or CSS as data:image/png;base64</simpara>
<itemizedlist>
<listitem>
<simpara>Base58 (Used for Bitcoin Addresses)</simpara>
<itemizedlist>
<listitem>
<simpara>Bitcoin addresses are encoded in Base58 to make them:</simpara>
<itemizedlist>
<listitem>
<simpara>Shorter than hexadecimal</simpara>
</listitem>
<listitem>
<simpara>Easier for humans to read by removing similar-looking characters, it excludes: 0 (zero), O (capital o), I (capital i), and l (lowercase L)</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<example>
<title>Bitcoin address looks like</title>
<simpara>1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</simpara>
</example>
<simpara><emphasis role="strong">Take-away</emphasis>:</simpara>
<simpara>Why Encoding Matters</simpara>
<itemizedlist>
<listitem>
<simpara>Human readability: Easier to write down, share, and verify.</simpara>
</listitem>
<listitem>
<simpara>Error reduction: Base58 specifically avoids characters that are commonly misread.</simpara>
</listitem>
<listitem>
<simpara>Data integrity: Encoded strings can still be verified cryptographically even if they are human-friendly.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_cryptographic_keys_mnemonics">
<title>Cryptographic keys - Mnemonics</title>
<simpara>The BIP-39 standard is a mnemonic system specifically designed for creating and recovering cryptographic keys in a human-readable way.
A mnemonic system helps people remember or record complex information more easily.</simpara>
<simpara>BIP-39 stands for Bitcoin Improvement Proposal 39.
It defines:
- How to create mnemonic phrases (like the 12, 18, or 24-word passphrases).
- How to convert those phrases into a cryptographic seed that can generate private keys and addresses.</simpara>
<example>
<title>a BIP-39 12-word seed</title>
<simpara>abandon ability able about above absent absorb abstract absurd abuse access accident</simpara>
</example>
<simpara>Substrate uses the dictionary of the <literal>BIP39</literal> standard.</simpara>
</section>
<section xml:id="_cryptographic_keys_address_format">
<title>Cryptographic keys - Address Format</title>
<simpara>In the context of cryptography, an address is essentially a public key.
In cryptocurrencies when talk about keys, usually we are talking about an address.</simpara>
<simpara>Addresses also include error check machanisms like checksum.
It is a simple however efficient way of checking if there was an error while copying or sendind an address information.
(if a single bit is wrong, the checksum will inform that the address is invalid).</simpara>
<simpara>Polkadot uses a specific address format, called SS58 which uses Base68 encoding and adds 2 bytes at the beginning of the address
to indicate the network. It also includes 2 bytes of checksum at the end.
SS58 Address format is designed keeping the multichain nature of Polkadot in mind.</simpara>
<simpara>You can use <link xl:href="https://polkadot.subscan.io/tools/format_transform">format-transform</link> tool to check the account address on the other chains in the Polkadot ecosystem.
There has been a significant debate within Polkadot ecosystem to unify the address format across chains.
You can see the discussion <link xl:href="https://forum.polkadot.network/t/unifying-polkadot-ecosystem-address-format/10042">here</link>.</simpara>
</section>
<section xml:id="_account_derivation_methods">
<title>Account Derivation Methods</title>
<simpara>Starting Point: Mnemonic Phrase, this is our master seed.</simpara>
<simpara>From this single seed, you can generate multiple accounts (each with their own public/private key pairs).
This process is called *Hierarchical Deterministic (HD) Wallet Derivation.
So, Key derivation allows one to derive (virtually limitless) child keys from one "parent".</simpara>
<simpara><emphasis role="strong">Why do we need account derivation?</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You don’t need a new mnemonic every time you want a new account.</simpara>
</listitem>
<listitem>
<simpara>You can generate unlimited accounts from one passphrase.</simpara>
</listitem>
<listitem>
<simpara>All accounts can be recovered from the same seed phrase.</simpara>
</listitem>
<listitem>
<simpara>Keeps backup simple — one phrase to secure everything.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">How It Works ?</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The 12-word phrase is converted into a master seed (a big random number).</simpara>
</listitem>
<listitem>
<simpara>The seed generates the first private key (root key).</simpara>
</listitem>
<listitem>
<simpara>Using derivation paths, you can systematically generate a new public/private keypair.</simpara>
</listitem>
<listitem>
<simpara>Each Account is Unique: different keys, different addresses — but all are mathematically connected to the same mnemonic root</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Each step is a new account (new public/private keypair).</title>
<para>
<screen>Account 0: m/44'/0'/0'/0/0
Account 1: m/44'/0'/0'/0/1
Account 2: m/44'/0'/0'/0/2</screen>
</para>
</formalpara>
<simpara><emphasis role="strong">Types</emphasis></simpara>
<simpara>There are two types of key derivation: Hard and Soft keys deivation.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Soft</emphasis> (Non-Hardened) derivation:</simpara>
<itemizedlist>
<listitem>
<simpara>Allows public key derivation using a parent public key.</simpara>
</listitem>
<listitem>
<simpara>You can derive child public keys from the parent public key alone (no need for the private key).</simpara>
</listitem>
<listitem>
<simpara>You cannot generate a child private key only with the parent public key.</simpara>
</listitem>
<listitem>
<simpara>You can derive BOTH child public and private keys from the parent private key.</simpara>
</listitem>
<listitem>
<simpara>Weakness: If someone has parent public key + any child private key → they can compute the parent private key.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hard</emphasis> (hardnened) derivation:</simpara>
<itemizedlist>
<listitem>
<simpara>You ALWAYS need the parent private key to derive anything.</simpara>
</listitem>
<listitem>
<simpara>From parent private key → can derive both child private keys and child public keys.</simpara>
</listitem>
<listitem>
<simpara>From parent public key → cannot derive anything (not even child public keys).</simpara>
</listitem>
<listitem>
<simpara>Safer: Even if someone has a child private key and the parent public key → they cannot compute the parent private key.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Use cases</emphasis></simpara>
<simpara><emphasis role="strong">Soft Derivation</emphasis> : Convenience &amp; Public Monitoring
- Watch-Only Wallets (Public View Wallets): You want to monitor incoming transactions without having access to private keys. Ex: Payment gateways, Block explorers,
- Lightweight Clients: Mobile or web wallets that want to generate public addresses quickly and safely.
- Payment Servers / POS Systems: A point-of-sale system that needs to generate fresh addresses for each customer, The POS system can derive child public keys without ever handling private keys.</simpara>
<simpara><emphasis role="strong">Hard Derivation</emphasis> : Security &amp; Privacy Protection
- Securing Master Private Keys: When you want to make sure that if a child private key is exposed, the master private key is still safe.
- Account Separation in Multi-Account Wallets: Different accounts for different users or purposes.
- Cold Storage Setups: Cold wallets for long-term storage. ensures that even if a receiving address private key is accidentally exposed, the whole wallet seed and other accounts are still safe.
- Multi-Signature Wallets (Partially Hardened): Wallets where multiple parties must sign transactions, ensure that shared public keys don’t leak sensitive structure or parent keys.</simpara>
</section>
<section xml:id="_activity_practical_example_of_hard_and_soft_key_derivation">
<title>Activity: practical example of hard and soft key derivation</title>
<simpara>An example and activity, we use Polkadot JS Extension as it provides ability to create and derive accounts using a mnemonic phrase.
Note: <link xl:href="https://polkadot.js.org/extension/">Polkadot JS Extension</link> is for developers only.
If you are a developer and would like to explore the Polkadot account generation process, check the <literal>Subkey</literal> tool.</simpara>
<simpara>The article mentioned in the video:  "How likely is it that someone could guess your Bitcoin private key?"</simpara>
</section>
</section>
</section>
<section xml:id="_digital_signatures">
<title>Digital Signatures</title>
<section xml:id="_properties">
<title>Properties</title>
<itemizedlist>
<listitem>
<simpara>ensures authenticity and integrity of digital communication, without reveling the private key.</simpara>
</listitem>
<listitem>
<simpara>authenticity: the message originates from the sender that claims to be the sender</simpara>
</listitem>
<listitem>
<simpara>integrity: the message was not altered during communication.</simpara>
</listitem>
</itemizedlist>
<simpara>Signature libraries should expose the following basic functions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>generate_key(r) &#8594; sk</literal> : generate a secret key (sk) from some 'r' input.</simpara>
</listitem>
<listitem>
<simpara>`public_key(sk) &#8594; pk ` : generate a public key (pk) from sk.</simpara>
</listitem>
<listitem>
<simpara><literal>sign(sk, m) &#8594; sig</literal> : takes sk and a message 'm' and returns a digital signature.</simpara>
</listitem>
<listitem>
<simpara><literal>verify(pk, m, sig) &#8594; bool</literal> : takes sk, m, and a signature and returns true if the signature is valid. false otherwise.</simpara>
</listitem>
</itemizedlist>
<simpara>Note that, is often more practical to sign the hash of a message, instead of the full message, therefore
sign and verify functions usually have the following forms instead:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>sign(sk, H(m)) &#8594; sib</literal></simpara>
</listitem>
<listitem>
<simpara><literal>verify(pk, H(m), sig) &#8594; bool</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Other properties of signatures:</simpara>
<itemizedlist>
<listitem>
<simpara>Non-repudiation: Yes, The sender cannot deny sending the message.</simpara>
</listitem>
<listitem>
<simpara>Confidentiality: No, weak <footnote><simpara>We say “weak confidentiality” instead of “no confidentiality” to acknowledge that while digital signatures don’t provide real secrecy, they might, in very specific or indirect ways, limit exposure slightly. But it’s never enough to rely on for actual security of secret information.</simpara></footnote> or absent because:</simpara>
<itemizedlist>
<listitem>
<simpara>The signature process does not hide the message.</simpara>
</listitem>
<listitem>
<simpara>The signed message remains readable by everyone.</simpara>
</listitem>
<listitem>
<simpara>The purpose is to verify authenticity, not to conceal content.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_digital_signatures_in_practice">
<title>Digital signatures in Practice</title>
<simpara>As just mentioned, in practice only the hash of a message is required to sign the message and verify the signature.
One challenge that signatures must address are replay attacks.
In a replay attack, the attacker intecepts the message and resends it to manipulate the system.
For instance, imagine that an attacker intercepts a message that transfer some amount of assets from account A to account B.
It replays (resends) this message multiple times in order to make multiple unauthorized transfers.</simpara>
<simpara>To prevent replay attacks, digital signatures usually implement additional information, such as nonces, timestamps or context information.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Nonces</emphasis> (Number used once):
A unique, random value added to each message.
Prevents duplication since the server checks whether the nonce has been used before.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Timestamps</emphasis>:
Ensure the message is only valid within a specific time window.
Prevents old messages from being reused.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Context Information</emphasis>:
includes any data that defines the environment or circumstances of a transaction.
Examples: session ID, timestamp, sender ID, location, protocol version, etc.
For instance, we can bind signatures to specific sessions, so they cannot be reused in a different context.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_digital_signatures_in_action">
<title>Digital Signatures in Action</title>
<simpara>This section shows a video of showing a transaction being sent from user A to B,
the highlight of this example is to show the incremental nonce added to the transaction by the wallet
as well as the timestamp that defined the lifetime that is added by the call.
Both are measure of preventing replay attacks.</simpara>
</section>
<section xml:id="_digital_signatures_elliptic_curves">
<title>Digital Signatures - Elliptic curves</title>
<simpara>There are several algorithms used to create digital signatures, each one with its strengths and use cases.
Some of the most prominent include:</simpara>
<section xml:id="_ecdsa_elliptic_curve_digital_signature_algorithm">
<title>ECDSA (Elliptic Curve Digital Signature Algorithm)</title>
<simpara>ECDSA is a widely used digital signature scheme based on elliptic curve cryptography (ECC).
It provides a way to verify the authenticity and integrity of digital messages or data.</simpara>
<simpara>Efficiency: ECDSA offers strong security with smaller key sizes compared to RSA, making it faster and more suitable for constrained environments.
Non-Deterministic: ECDSA relies on generating a random nonce for each signature; if the nonce is reused or predictable, it can compromise the private key.
Usage: Common in Bitcoin, Ethereum, TLS, and many cryptographic protocols.</simpara>
<simpara>Limitations of ECDSA:</simpara>
<itemizedlist>
<listitem>
<simpara>Nonce Sensitivity:</simpara>
<itemizedlist>
<listitem>
<simpara>Biggest Weakness: ECDSA critically depends on using a unique, high-quality random nonce (per signature).</simpara>
</listitem>
<listitem>
<simpara>Risk: If the same nonce is reused, or if the nonce is partially predictable, the private key can be fully recovered.</simpara>
</listitem>
<listitem>
<simpara>Example: Several real-world attacks (including on Bitcoin wallets) have exploited poor nonce generation to steal private keys.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Non-Deterministic by Default:</simpara>
<itemizedlist>
<listitem>
<simpara>ECDSA traditionally relies on external randomness for each signature, which can introduce security risks if the random number generator is flawed.</simpara>
</listitem>
<listitem>
<simpara>Deterministic variants (like RFC 6979) have been proposed but are not always implemented.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Complex Implementation</simpara>
<itemizedlist>
<listitem>
<simpara>ECDSA is more mathematically complex than some alternatives like EdDSA, making it harder to implement securely and efficiently.</simpara>
</listitem>
<listitem>
<simpara>More prone to side-channel attacks if not carefully designed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Slower than Modern Alternatives:</simpara>
<itemizedlist>
<listitem>
<simpara>ECDSA is generally slower than Ed25519, both in signing and verifying, especially on constrained devices.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Larger Signature Size Compared to Ed25519:</simpara>
<itemizedlist>
<listitem>
<simpara>While smaller than RSA, ECDSA signatures are typically larger and slower to verify than Ed25519, which has become a more preferred standard in modern cryptography.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_ed25519_edwards_curve_digital_signature_algorithm">
<title>Ed25519 (Edwards-curve Digital Signature Algorithm)</title>
<simpara>Ed25519 is a high-performance, modern digital signature algorithm that implements the Edwards-curve Digital Signature Algorithm using the Edwards curve Ed25519.</simpara>
<itemizedlist>
<listitem>
<simpara>It is designed to provide fast, secure, and compact signatures with strong resistance to common cryptographic attacks.</simpara>
</listitem>
<listitem>
<simpara>Deterministic Signatures: Eliminates nonce-related vulnerabilities by generating nonces deterministically from the private key and message.</simpara>
</listitem>
<listitem>
<simpara>High Performance: Faster signing and verification compared to ECDSA, especially on low-power or embedded devices.</simpara>
</listitem>
<listitem>
<simpara>Compact Size: Public keys are 32 bytes and signatures are 64 bytes, which saves storage and bandwidth.</simpara>
</listitem>
<listitem>
<simpara>Side-Channel Resistance: Designed to minimize the risk of timing and side-channel attacks.</simpara>
</listitem>
<listitem>
<simpara>Widely Adopted: Used in modern systems like SSH, TLS 1.3, cryptocurrencies (like Monero), and secure messaging apps</simpara>
</listitem>
<listitem>
<simpara>Ed25519 is inspired by Schnorr signatures but is a more advanced and standardized form, adapted to use modern elliptic curve techniques and deterministic signing.</simpara>
</listitem>
</itemizedlist>
<simpara>Limitations of Ed25519:</simpara>
<itemizedlist>
<listitem>
<simpara>Curve Rigidity</simpara>
<itemizedlist>
<listitem>
<simpara>Ed25519 uses a fixed curve (the Edwards form of Curve25519).</simpara>
</listitem>
<listitem>
<simpara>Unlike ECDSA, which can work over various NIST curves, Ed25519 offers no flexibility to choose different elliptic curves.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Limited Support for Advanced Features</simpara>
<itemizedlist>
<listitem>
<simpara>ECDSA can be more easily adapted to schemes like threshold signatures or certain multi-signature protocols.</simpara>
</listitem>
<listitem>
<simpara>Ed25519 requires additional construction (like MuSig2 or other schemes) for efficient multi-signature set</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_sr25519_schnorrkelristretto_x25519">
<title>Sr25519 (Schnorrkel/Ristretto x25519):</title>
<simpara>Sr25519 is a modern digital signature scheme based on Schnorr signatures using the Ristretto group, which is derived from Curve25519.</simpara>
<simpara>It is specifically designed for use in modern blockchain platforms like Polkadot and Substrate.</simpara>
<itemizedlist>
<listitem>
<simpara>Based on Schnorr Signatures: Offers simple security proofs and strong resistance to common cryptographic attacks.</simpara>
</listitem>
<listitem>
<simpara>Uses Ristretto: This solves the cofactor issues of elliptic curves and provides a clean, prime-order group for better cryptographic properties.</simpara>
</listitem>
<listitem>
<simpara>Deterministic Signatures: Like Ed25519, Sr25519 uses deterministic nonce generation, avoiding the nonce reuse problems of ECDSA.</simpara>
</listitem>
<listitem>
<simpara>Batch Verification: Supports efficient batch signature verification, improving performance when validating many signatures at once.</simpara>
</listitem>
<listitem>
<simpara>Native Support for  multi-signature schemes, zero-knowledge-friendly constructs.</simpara>
</listitem>
<listitem>
<simpara>Optimized for Blockchain: Specifically built for high-performance, scalable blockchain systems.</simpara>
</listitem>
</itemizedlist>
<simpara>Limitations of Sr25519</simpara>
<itemizedlist>
<listitem>
<simpara>Limited Adoption Outside Specific Ecosystems:  Sr25519 is currently most widely used in the Polkadot ecosystem. Broader adoption in standards like TLS, SSH, or legacy systems is still very limited.</simpara>
</listitem>
<listitem>
<simpara>Complexity Compared to Ed25519: The Ristretto abstraction adds a layer of complexity that makes Sr25519 slightly harder to understand and implement from scratch compared to Ed25519.</simpara>
</listitem>
<listitem>
<simpara>Less Mature Tooling: Although rapidly improving, Sr25519 has less mature libraries and tooling across all platforms compared to Ed25519 or ECDSA. Integration in multi-language environments is still catching up.</simpara>
</listitem>
<listitem>
<simpara>Larger Signature Size Than ECDSA: Sr25519 signatures are similar in size to Ed25519 (64 bytes), which is larger than the smallest possible ECDSA signatures when using certain curves and optimizations.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_summary_table">
<title>Summary table</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Feature</entry>
<entry align="left" valign="top">ECDSA</entry>
<entry align="left" valign="top">Ed25519</entry>
<entry align="left" valign="top">Sr25519</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Cryptographic Basis</simpara></entry>
<entry align="left" valign="top"><simpara>Elliptic Curve Digital Signature Algorithm (ECDSA)</simpara></entry>
<entry align="left" valign="top"><simpara>Edwards-curve Digital Signature Algorithm (EdDSA)</simpara></entry>
<entry align="left" valign="top"><simpara>Schnorr Signatures over Ristretto (based on Curve25519)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Deterministic Signatures</simpara></entry>
<entry align="left" valign="top"><simpara>No (requires secure random nonce)</simpara></entry>
<entry align="left" valign="top"><simpara>Yes (deterministic nonce from message and private key)</simpara></entry>
<entry align="left" valign="top"><simpara>Yes (deterministic nonce from message and private key)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Nonce Sensitivity</simpara></entry>
<entry align="left" valign="top"><simpara>High (reuse can leak private key)</simpara></entry>
<entry align="left" valign="top"><simpara>Low (deterministic nonce generation)</simpara></entry>
<entry align="left" valign="top"><simpara>Low (deterministic nonce generation)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Key Size</simpara></entry>
<entry align="left" valign="top"><simpara>Typically 32 bytes (256-bit curve)</simpara></entry>
<entry align="left" valign="top"><simpara>32 bytes</simpara></entry>
<entry align="left" valign="top"><simpara>32 bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Signature Size</simpara></entry>
<entry align="left" valign="top"><simpara>Variable, often ~70 bytes</simpara></entry>
<entry align="left" valign="top"><simpara>64 bytes</simpara></entry>
<entry align="left" valign="top"><simpara>64 bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Performance</simpara></entry>
<entry align="left" valign="top"><simpara>Moderate (slower than Ed25519/Sr25519)</simpara></entry>
<entry align="left" valign="top"><simpara>Very fast (optimized for speed)</simpara></entry>
<entry align="left" valign="top"><simpara>Fast, with efficient batch verification</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Batch Verification</simpara></entry>
<entry align="left" valign="top"><simpara>Less efficient</simpara></entry>
<entry align="left" valign="top"><simpara>Supported</simpara></entry>
<entry align="left" valign="top"><simpara>Highly efficient</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Multi-signature Support</simpara></entry>
<entry align="left" valign="top"><simpara>Requires custom protocols</simpara></entry>
<entry align="left" valign="top"><simpara>Possible but complex</simpara></entry>
<entry align="left" valign="top"><simpara>Natively supported, more efficient</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Side-Channel Resistance</simpara></entry>
<entry align="left" valign="top"><simpara>Prone if not carefully implemented</simpara></entry>
<entry align="left" valign="top"><simpara>Designed to resist side-channel attacks</simpara></entry>
<entry align="left" valign="top"><simpara>Designed to resist side-channel attacks</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ecosystem Adoption</simpara></entry>
<entry align="left" valign="top"><simpara>Widely used (Bitcoin, Ethereum, TLS, legacy systems)</simpara></entry>
<entry align="left" valign="top"><simpara>Widely used (SSH, TLS 1.3, modern systems)</simpara></entry>
<entry align="left" valign="top"><simpara>Primarily in Polkadot, Substrate, emerging adoption</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tooling &amp; Libraries</simpara></entry>
<entry align="left" valign="top"><simpara>Mature, broadly available</simpara></entry>
<entry align="left" valign="top"><simpara>Mature, broadly available</simpara></entry>
<entry align="left" valign="top"><simpara>Growing, but less mature across all platforms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Flexibility of Curve Choice</simpara></entry>
<entry align="left" valign="top"><simpara>Multiple curves (e.g., secp256k1, P-256)</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed to Ed25519</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed to Ristretto derived from Curve25519</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Use Cases</simpara></entry>
<entry align="left" valign="top"><simpara>Traditional financial systems, blockchain, secure communication</simpara></entry>
<entry align="left" valign="top"><simpara>Modern secure systems, SSH, cryptocurrencies, messaging apps</simpara></entry>
<entry align="left" valign="top"><simpara>Blockchain (Polkadot, Substrate), scalable decentralized systems</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_multi_signatures">
<title>Multi-Signatures</title>
<simpara>Multi-signature (multi-sig) is a cryptographic technique that requires multiple parties to jointly authorize a transaction or message.
Instead of relying on a single private key, a group of keys must collaborate to produce a valid signature.</simpara>
<itemizedlist>
<listitem>
<simpara>A multi-sig account is controlled by a set of individuals that hold each their own pub/priv key pairs.</simpara>
</listitem>
<listitem>
<simpara>The multi-sig account have only a public key, but not a private key.</simpara>
</listitem>
<listitem>
<simpara>Funds can be sent to the public address of the multi-sig account and they can only be moved out if there is a
preset threshold of signatures received.</simpara>
</listitem>
</itemizedlist>
<informalexample>
<simpara>A “2-of-3” multi-sig wallet requires any 2 out of 3 participants to approve a transaction before it can be executed.</simpara>
</informalexample>
<simpara><emphasis role="strong">Advantages</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Enhanced Security: Reduces risk of single key compromise.</simpara>
</listitem>
<listitem>
<simpara>Shared Control: Useful for organizations, families, or teams to manage joint assets.</simpara>
</listitem>
<listitem>
<simpara>Trustless Collaboration: No need for a central authority; signatures can be verified collectively.</simpara>
</listitem>
<listitem>
<simpara>Resistance to Theft: Even if one key is stolen, funds or access remain secure.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Use Cases</emphasis>
- Cryptocurrency Wallets: Bitcoin, Ethereum, Polkadot (shared wallets with multiple owners).
- Decentralized Governance: Multi-party control of treasury funds.
- Escrow Services: Conditional transactions requiring multiple approvals.
- Cross-Chain Bridges: Secure multi-party authorization for asset transfers between blockchains.
- Enterprise Access Control: Secure corporate signing processes.</simpara>
<simpara><emphasis role="strong">Limitations</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Complexity: More complicated setup and key management.</simpara>
</listitem>
<listitem>
<simpara>Higher Transaction Fees: Multi-sig transactions can be larger and more expensive on-chain (notably in Bitcoin).</simpara>
</listitem>
<listitem>
<simpara>Limited Privacy: Traditional multi-sig (like Bitcoin’s) can reveal the number of participants and threshold on the blockchain.</simpara>
</listitem>
<listitem>
<simpara>Interoperability: Not all wallets, smart contracts, or protocols natively support multi-sig.</simpara>
</listitem>
<listitem>
<simpara>Recovery Challenges: Loss of multiple keys can permanently lock access.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Anonimity/Privacy</emphasis></simpara>
<simpara>The anonymity of signers in a multi-signature group depends heavily on the type of multi-sig scheme used.
It is possible to check each of the members of a multi-sig group has signed a message.
But there are some multi-sig schemes that preserv the anonimity of the signers. For instance Ring signatures preserve the anonumity.</simpara>
<itemizedlist>
<listitem>
<simpara>Traditional Multi-Sig (e.g., Bitcoin P2SH)</simpara>
<itemizedlist>
<listitem>
<simpara>Visibility: The multi-sig structure is publicly visible on the blockchain.</simpara>
</listitem>
<listitem>
<simpara>Low anonymity – signers and signing policies are exposed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>MuSig and MuSig2 (Schnorr-based Multi-Sig)</simpara>
<itemizedlist>
<listitem>
<simpara>All participant keys are aggregated into a single public key.</simpara>
</listitem>
<listitem>
<simpara>The resulting signature is indistinguishable from a single-signer signature.</simpara>
</listitem>
<listitem>
<simpara>High anonymity – no information about the number of participants or individual signers is revealed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Threshold Signature Schemes (TSS)</simpara>
<itemizedlist>
<listitem>
<simpara>TSS allows a group to jointly compute a signature without ever revealing individual key shares.</simpara>
</listitem>
<listitem>
<simpara>To outside observers, the signature looks like it was produced by a single key.</simpara>
</listitem>
<listitem>
<simpara>Strong anonymity – individual signers remain hidden, no signer metadata is leaked</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Smart Contract Multi-Sig (e.g., Gnosis Safe on Ethereum)</simpara>
<itemizedlist>
<listitem>
<simpara>The contract publicly records which keys are authorized and which keys signed each transaction.</simpara>
</listitem>
<listitem>
<simpara>Low to medium anonymity – signer identities and approval history are usually on-chain.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<section xml:id="_quick_comparation_table">
<title>Quick comparation table</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Scheme</entry>
<entry align="left" valign="top">Signer Anonymity</entry>
<entry align="left" valign="top">Requires Group Manager</entry>
<entry align="left" valign="top">Notes</entry>
<entry align="left" valign="top">Common Use</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Aggregated Signatures</simpara></entry>
<entry align="left" valign="top"><simpara>Low (unless using MuSig2)</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Compress multiple signatures into one</simpara></entry>
<entry align="left" valign="top"><simpara>Blockchain consensus, BLS signatures</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ring Signatures</simpara></entry>
<entry align="left" valign="top"><simpara>Strong</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Untraceable, signer hidden within group</simpara></entry>
<entry align="left" valign="top"><simpara>Privacy coins (e.g., Monero), anonymous reporting</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Group Signatures</simpara></entry>
<entry align="left" valign="top"><simpara>Conditional</simpara></entry>
<entry align="left" valign="top"><simpara>Yes (optional traceability)</simpara></entry>
<entry align="left" valign="top"><simpara>Anonymity with controlled accountability</simpara></entry>
<entry align="left" valign="top"><simpara>Corporate voting, permissioned blockchains</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Threshold Signatures</simpara></entry>
<entry align="left" valign="top"><simpara>Varies (can be anonymous)</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Distributed signing, no single key exposure</simpara></entry>
<entry align="left" valign="top"><simpara>Custodial wallets, distributed ledgers, cross-chain bridges</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Tools and Protocols</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>Bitcoin:</simpara>
<itemizedlist>
<listitem>
<simpara>Native P2SH (Pay-to-Script-Hash) multi-sig</simpara>
</listitem>
<listitem>
<simpara>MuSig and MuSig2 (next-gen Schnorr-based multi-sig with privacy and efficiency improvements)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Ethereum:</simpara>
<itemizedlist>
<listitem>
<simpara>Gnosis Safe</simpara>
</listitem>
<listitem>
<simpara>Smart contract multi-sig wallet, industry standard</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Polkadot/Substrate:</simpara>
<itemizedlist>
<listitem>
<simpara>Native multi-sig support via Sr25519</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cardano:</simpara>
<itemizedlist>
<listitem>
<simpara>Native multi-sig scripts</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>General:</simpara>
<itemizedlist>
<listitem>
<simpara>TSS (Threshold Signature Schemes): Used in Fireblocks, ZenGo, and other wallet infrastructures for keyless multi-party signatures.</simpara>
</listitem>
<listitem>
<simpara>MuSig2 (Bitcoin, Schnorr-based): Efficient, private, and scalable multi-sig protocol.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_multi_signature_accounts_in_action">
<title>Multi-Signature Accounts in Action</title>
<simpara>For enterprise grade management of multi-sig account some tools are available like:</simpara>
<itemizedlist>
<listitem>
<simpara>Talisman Signet</simpara>
</listitem>
<listitem>
<simpara>Multix from chainsafe</simpara>
</listitem>
</itemizedlist>
<simpara>This section is mostly a video example of using Polkadot-JS for showing multi-sigs in action.</simpara>
<simpara>In <literal>polkadot-js</literal> we can add addresses in our contacts (address book).
Then, we can select add a multi sig account and select the addresses for this account from our address book.
We set the threashold, and the name for the group.
The example shows the use of the multi-sig using Passeo testnet , to simulate the use to sending some assets with a multi-sig account.</simpara>
</section>
<section xml:id="_references_2">
<title>References</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://wiki.polkadot.network/learn/learn-cryptography/">https://wiki.polkadot.network/learn/learn-cryptography/</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://en.wikipedia.org/wiki/Digital_signature">https://en.wikipedia.org/wiki/Digital_signature</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cqi.inf.usi.ch/blog/four.html">https://cqi.inf.usi.ch/blog/four.html</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/6-Advanced_Signatures-slides.html#/4">https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/6-Advanced_Signatures-slides.html#/4</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_hash_based_data_structures">
<title>Hash based Data Structures</title>
<section xml:id="_data_structures_for_beginers">
<title>Data Structures for beginers</title>
<itemizedlist>
<listitem>
<simpara>What are data structures</simpara>
</listitem>
</itemizedlist>
<simpara>Discuss few of them:</simpara>
<itemizedlist>
<listitem>
<simpara>Arrays</simpara>
</listitem>
<listitem>
<simpara>LinkedLists</simpara>
</listitem>
<listitem>
<simpara>Trees&#8201;&#8212;&#8201;max heap&#8201;&#8212;&#8201;binary search tree</simpara>
</listitem>
</itemizedlist>
<simpara>each data structure has its own advatages and cons, depending on the use case.
we will see later that blockchains benifit from organizing data in a specific structure</simpara>
</section>
<section xml:id="_hash_chains">
<title>Hash Chains</title>
<itemizedlist>
<listitem>
<simpara>hash based data structures (breafly compare with pointers if it is a good thing)</simpara>
</listitem>
</itemizedlist>
<simpara>key feature:  one-way functions
we cant have cyclic structures with hashes
hashes only allow to reference previous data, never future data</simpara>
<itemizedlist>
<listitem>
<simpara>hash chains , explain it and its features</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_merkle_trees">
<title>Merkle Trees</title>
<itemizedlist>
<listitem>
<simpara>another key data structure in the context of block chains</simpara>
</listitem>
<listitem>
<simpara>explain: binary tree where the value of each parent node is the hash of the child</simpara>
</listitem>
<listitem>
<simpara>allows to prove the information  about the tree without reveal the entire dataset</simpara>
</listitem>
<listitem>
<simpara>allow to commit to the entire the entire dataset , by using the root hash
we cannot change anu part of the tree without changing the root</simpara>
</listitem>
<listitem>
<simpara>explain why it is benificial for blockchains</simpara>
</listitem>
</itemizedlist>
<section xml:id="_merkle_example">
<title>Merkle Example</title>
<itemizedlist>
<listitem>
<simpara>give an example of how to built a merkle tree and how to prove / verify values with it</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_efficient_data_structures">
<title>Efficient data structures</title>
<itemizedlist>
<listitem>
<simpara>briefly explain key value data bases</simpara>
</listitem>
<listitem>
<simpara>explain a trie</simpara>
</listitem>
<listitem>
<simpara>radix trie</simpara>
</listitem>
<listitem>
<simpara>patricia tries</simpara>
</listitem>
<listitem>
<simpara>explain MMR Merkle mountain range</simpara>
</listitem>
</itemizedlist>
<simpara>&#8201;&#8212;&#8201;also explain how to build and prove/verify&#8201;&#8212;&#8201;mention advantatges regarding to traditional merkle trees.</simpara>
</section>
<section xml:id="_summary_take_away">
<title>Summary / Take-away</title>
<itemizedlist>
<listitem>
<simpara>provie a summary take-away</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_references_3">
<title>References</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://medium.com/@DevChy/introduction-to-data-structures-with-real-world-examples-15063e4adbad">https://medium.com/@DevChy/introduction-to-data-structures-with-real-world-examples-15063e4adbad</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/7-Hash_Based_Data_Structures-slides.html#/1">https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/7-Hash_Based_Data_Structures-slides.html#/1</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_advanced_cryptography_topics">
<title>Advanced Cryptography Topics</title>
<section xml:id="_advanced_cryptography_primitives">
<title>Advanced Cryptography Primitives</title>
<simpara>We have previously seen that multi-sig schemes can be usefull to avoid single point of failures and
loss of keys of one or more accounts in a threshold multi-sig.
One inconvenient side of using multi-sig for this purpose is that we have to manage multiple accounts and their private keys.</simpara>
<simpara>There is another technique that helps us to preserve a single private key across multiple locations to avoid loss and failures.
That is Shamir secret sharing.</simpara>
<section xml:id="_shamir_secret_sharing">
<title>Shamir secret sharing</title>
<simpara>Shamir’s Secret Sharing (SSS) is a cryptographic method invented by Adi Shamir in 1979.
It allows a secret (like a password or cryptographic key) to be split into multiple parts (shares).
Only a minimum number of those parts (a threshold) is needed to reconstruct the secret.
Less than that provides no information.
This technique is similar to erasure coding techniques.</simpara>
<simpara>It is based on polynomial interpolation over finite fields:</simpara>
<itemizedlist>
<listitem>
<simpara>Any k points uniquely determine a polynomial of degree k−1.</simpara>
</listitem>
<listitem>
<simpara>Shares are points on a secret polynomial; the secret is the y-intercept.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Benefits</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>High Security: No information is leaked unless the threshold is met.</simpara>
</listitem>
<listitem>
<simpara>Redundancy: Shares can be distributed across multiple parties/locations to protect against data loss.</simpara>
</listitem>
<listitem>
<simpara>Flexible Access Control: You can set custom thresholds (e.g., 3 out of 5 shares).</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Limitations</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Requires Secure Distribution: Shares must be securely delivered to participants.</simpara>
</listitem>
<listitem>
<simpara>No Share Renewal: Shares can’t be easily changed without redistributing new ones.</simpara>
</listitem>
<listitem>
<simpara>No Protection Against Collusion: If the threshold is met by colluding parties, the secret is fully revealed.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Common Use Cases</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Cryptocurrency Wallet Recovery: Splitting wallet keys among trusted parties.</simpara>
</listitem>
<listitem>
<simpara>Key Management Systems: Secure backup of encryption keys.</simpara>
</listitem>
<listitem>
<simpara>Nuclear Launch Codes: Distributed control among several decision-makers.</simpara>
</listitem>
<listitem>
<simpara>Secure Multi-Party Agreements: Joint authorization requirements.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_quick_comparison_table_sss_vs_multi_sig">
<title>Quick comparison table: SSS vs Multi-sig</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Feature</entry>
<entry align="left" valign="top">SSS</entry>
<entry align="left" valign="top">Multi-Sig</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Concept</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Splits a single secret into parts</simpara></entry>
<entry align="left" valign="top"><simpara>Multiple parties each have their own key</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Threshold</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Reconstruct secret with k of n shares</simpara></entry>
<entry align="left" valign="top"><simpara>Requires k of n signatures to validate</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Trust Model</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Secret is fully revealed when threshold is met</simpara></entry>
<entry align="left" valign="top"><simpara>Secret is never reconstructed; signatures prove agreement</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Risk</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Colluding threshold can expose the secret</simpara></entry>
<entry align="left" valign="top"><simpara>Colluding threshold can approve transactions, but secret keys stay private</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Use Case</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Key backup, disaster recovery</simpara></entry>
<entry align="left" valign="top"><simpara>Decentralized control (blockchains, wallets)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</section>
<section xml:id="_on_chain_randomness_vrfs">
<title>On-chain randomness - VRFs</title>
<simpara>Another interesting technique used in blockchains is VRF that is used to obtain private randomness, that is publicly verifiable.</simpara>
<section xml:id="_vrf_verifiable_random_function">
<title>VRF: Verifiable Random Function</title>
<simpara>A Verifiable Random Function (VRF) is like a cryptographic “random lottery” with proof.
It produces a random-looking output that is:
- Unique: Deterministic for the same input.
- Verifiable: Anyone can check that the output is correct without knowing the secret key.</simpara>
<simpara>It’s similar to a cryptographic hash function, but with proof of correctness tied to a private key.
Introduced by Micali, Rabin, and Vadhan in 1999, but gained significant use in blockchain protocols for leader selection and randomness generation.</simpara>
<simpara><emphasis role="strong">Interface</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>eval(sk,input) &#8594; output</simpara>
</listitem>
<listitem>
<simpara>sign(sk, input) &#8594; signature</simpara>
</listitem>
<listitem>
<simpara>verify(pk, input, signature) &#8594; option output</simpara>
</listitem>
</itemizedlist>
<simpara>The input can be a number that is known publicly and is agreed upon to be the input by all the participants.
By combining the input with the secret key (sk), which is known only to the secret key owner, and computing a hash of it results in an output that is pseudo-random.
This output can be revealed along with the signature later on, which can be verified by anyone by using their public key (pk).</simpara>
<simpara><emphasis role="strong">Output properties</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>Output is a deterministic function of key and input, i.e. eval should be deterministic</simpara>
</listitem>
<listitem>
<simpara>It should be pseudo-random</simpara>
</listitem>
<listitem>
<simpara>But until the VRF proof is revealed, only the holder of the secret key knows the output</simpara>
</listitem>
<listitem>
<simpara>Revealing output does not leak secret key</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Usage</emphasis></simpara>
<simpara>Choose input after key, then the key holder cannot influence the output.
The output then is effectively a random number known only to the key holder.
But they can later reveal it, by publishing the VRF proof (signature).</simpara>
<simpara><emphasis role="strong">Benefits</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Unpredictability: Results can’t be predicted without the secret key.</simpara>
</listitem>
<listitem>
<simpara>Verifiability: Others can independently verify the output using the public key.</simpara>
</listitem>
<listitem>
<simpara>Fairness: Used to select participants randomly and fairly.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Limitations</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Requires Setup: Needs public/private key infrastructure.</simpara>
</listitem>
<listitem>
<simpara>Deterministic: Given the same input and key, the output is always the same (can be a feature or a limitation).</simpara>
</listitem>
<listitem>
<simpara>Complexity: More computationally intensive than simple random functions.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Common Use Cases</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Blockchain Leader Election: Example: Algorand uses VRFs to select block proposers randomly but verifiably.</simpara>
</listitem>
<listitem>
<simpara>Random Number Generation: Secure lotteries, random selections where proof is required.</simpara>
</listitem>
<listitem>
<simpara>Spam Prevention: Proof that a request is legitimate, used in anti-spam mechanisms.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>Players want to draw cards randomly and fairly without trusting each other or a central dealer.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Players Agree on a Random Input</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>All players agree on a shared random number x (this can come from a shared source like a blockchain block hash or a collectively agreed event).</simpara>
</listitem>
<listitem>
<simpara>This ensures no single player can choose the input to bias the result.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Player A Draws a Card Using a VRF</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Player A has a secret key (sk_A) and a corresponding public key.</simpara>
</listitem>
<listitem>
<simpara>A uses their VRF function to compute: <literal>y = \text{eval}(sk_A, x) \mod 52</literal></simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara><literal>eval(sk_A, x)</literal> : produces a pseudo-random but deterministic number tied to A’s secret key and input x.</simpara>
</listitem>
<listitem>
<simpara>mod 52 : maps the number to one of the 52 cards in a deck.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Result</emphasis>: Player A’s card is uniquely determined by their secret key and the shared input x. No one can predict A’s card in advance.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Player A Publishes the VRF Proof</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Along with the card, A publishes the VRF proof (a special signature).</simpara>
</listitem>
<listitem>
<simpara>This proof allows all other players to verify:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>That A followed the correct process.</simpara>
</listitem>
<listitem>
<simpara>That A didn’t cheat or pick a different card.</simpara>
<itemizedlist>
<listitem>
<simpara>The proof is verifiable using A’s public key and the shared input x.</simpara>
</listitem>
<listitem>
<simpara>Players can check the card without knowing A’s secret key.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_vrf_types">
<title>VRF Types</title>
<simpara>Some important variations of VRFs are:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Threshold VRF:</simpara>
<simpara>A Threshold VRF allows a group of participants to jointly compute a VRF output without any single participant knowing the whole secret key.</simpara>
<itemizedlist>
<listitem>
<simpara>The VRF secret key is split (e.g., using Shamir’s Secret Sharing).</simpara>
</listitem>
<listitem>
<simpara>A minimum number (threshold) of participants must cooperate to produce the VRF output and proof.</simpara>
</listitem>
<listitem>
<simpara>No single party controls the randomness.</simpara>
<simpara><emphasis role="strong">Benefits</emphasis>:</simpara>
</listitem>
<listitem>
<simpara>Decentralized and fault-tolerant.</simpara>
</listitem>
<listitem>
<simpara>Prevents bias or control by any single participant.</simpara>
</listitem>
<listitem>
<simpara>Used in decentralized randomness beacons (like in Dfinity’s consensus).</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Ring VRF</simpara>
<simpara>A Ring VRF lets a participant generate a VRF output that is provably valid but anonymously linked to a group.</simpara>
<itemizedlist>
<listitem>
<simpara>The proof shows the result was produced by someone in a predefined group but doesn’t reveal who.</simpara>
</listitem>
<listitem>
<simpara>Combines VRF with ring signatures (anonymous group signatures).</simpara>
<simpara><emphasis role="strong">Benefits</emphasis>:</simpara>
</listitem>
<listitem>
<simpara>Anonymity: Keeps the identity of the VRF generator hidden.</simpara>
</listitem>
<listitem>
<simpara>Verifiability: Others can still verify the result came from a valid group member.</simpara>
</listitem>
<listitem>
<simpara>Useful in privacy-preserving protocols, anonymous lotteries, or leader selection.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_vrfs_take_away">
<title>VRFs Take-away:</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Fairness</emphasis> comes from agreed input. No central dealer needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Randomness</emphasis> comes from VRF evaluation. The combination of public input + secret key.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Security</emphasis> comes from verifiable proof. A cannot lie about their draw.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Unpredictability</emphasis> comes from the fact that results cannot be predicted without the secret key. Other players cannot predict or control the card A will draw.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_references_4">
<title>References</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://chain.link/education-hub/verifiable-random-function-vrf">https://chain.link/education-hub/verifiable-random-function-vrf</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.polkadot.com/polkadot-protocol/basics/randomness/#vrf">https://docs.polkadot.com/polkadot-protocol/basics/randomness/#vrf</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://eprint.iacr.org/2023/002.pdf">https://eprint.iacr.org/2023/002.pdf</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
</book>